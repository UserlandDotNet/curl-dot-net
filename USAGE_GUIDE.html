<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>CurlDotNet Usage Guide | CurlDotNet - Pure .NET curl for C# </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="CurlDotNet Usage Guide | CurlDotNet - Pure .NET curl for C# ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/jacob-mellor/curl-dot-net/blob/master/docs/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="CurlDotNet">
            CurlDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="curldotnet-usage-guide">CurlDotNet Usage Guide</h1>

<p>This comprehensive guide covers common usage scenarios for CurlDotNet, from basic requests to advanced patterns.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#basic-http-operations">Basic HTTP Operations</a></li>
<li><a href="#working-with-json">Working with JSON</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#file-operations">File Operations</a></li>
<li><a href="#advanced-patterns">Advanced Patterns</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#testing-and-mocking">Testing and Mocking</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ol>
<h2 id="getting-started">Getting Started</h2>
<h3 id="installation">Installation</h3>
<pre><code class="lang-bash">dotnet add package CurlDotNet
</code></pre>
<h3 id="basic-setup">Basic Setup</h3>
<pre><code class="lang-csharp">using CurlDotNet;
using CurlDotNet.Core;

// Simplest usage - direct curl command
var result = await Curl.ExecuteAsync(&quot;curl https://api.example.com&quot;);

// Using convenience methods
var result = await Curl.GetAsync(&quot;https://api.example.com&quot;);
</code></pre>
<h2 id="basic-http-operations">Basic HTTP Operations</h2>
<h3 id="get-requests">GET Requests</h3>
<pre><code class="lang-csharp">// Simple GET
var result = await Curl.GetAsync(&quot;https://api.example.com/users&quot;);

// GET with query parameters
var result = await Curl.GetAsync(&quot;https://api.example.com/users?page=1&amp;limit=10&quot;);

// GET with headers
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/users&quot;)
    .AddHeader(&quot;Accept&quot;, &quot;application/json&quot;)
    .AddHeader(&quot;X-API-Version&quot;, &quot;2.0&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="post-requests">POST Requests</h3>
<pre><code class="lang-csharp">// POST with JSON body
var json = &quot;{\&quot;name\&quot;:\&quot;John Doe\&quot;,\&quot;email\&quot;:\&quot;john@example.com\&quot;}&quot;;
var result = await Curl.PostAsync(
    &quot;https://api.example.com/users&quot;,
    json,
    &quot;application/json&quot;
);

// POST with form data
var formData = &quot;username=john&amp;password=secret&quot;;
var result = await Curl.PostAsync(
    &quot;https://api.example.com/login&quot;,
    formData,
    &quot;application/x-www-form-urlencoded&quot;
);

// POST with custom headers
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/users&quot;)
    .SetMethod(&quot;POST&quot;)
    .SetBody(json)
    .AddHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)
    .AddHeader(&quot;X-Request-ID&quot;, Guid.NewGuid().ToString())
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="put-requests">PUT Requests</h3>
<pre><code class="lang-csharp">// PUT to update resource
var updateData = &quot;{\&quot;name\&quot;:\&quot;Jane Doe\&quot;,\&quot;email\&quot;:\&quot;jane@example.com\&quot;}&quot;;
var result = await Curl.PutAsync(
    &quot;https://api.example.com/users/123&quot;,
    updateData,
    &quot;application/json&quot;
);

// PUT with file upload
var fileContent = File.ReadAllBytes(&quot;document.pdf&quot;);
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/files/document.pdf&quot;)
    .SetMethod(&quot;PUT&quot;)
    .SetBody(fileContent)
    .AddHeader(&quot;Content-Type&quot;, &quot;application/pdf&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="delete-requests">DELETE Requests</h3>
<pre><code class="lang-csharp">// Simple DELETE
var result = await Curl.DeleteAsync(&quot;https://api.example.com/users/123&quot;);

// DELETE with confirmation header
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/users/123&quot;)
    .SetMethod(&quot;DELETE&quot;)
    .AddHeader(&quot;X-Confirm-Delete&quot;, &quot;true&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="patch-requests">PATCH Requests</h3>
<pre><code class="lang-csharp">// PATCH for partial updates
var patchData = &quot;[{\&quot;op\&quot;:\&quot;replace\&quot;,\&quot;path\&quot;:\&quot;/email\&quot;,\&quot;value\&quot;:\&quot;new@example.com\&quot;}]&quot;;
var result = await Curl.PatchAsync(
    &quot;https://api.example.com/users/123&quot;,
    patchData,
    &quot;application/json-patch+json&quot;
);
</code></pre>
<h2 id="working-with-json">Working with JSON</h2>
<h3 id="parsing-json-responses">Parsing JSON Responses</h3>
<pre><code class="lang-csharp">using System.Text.Json;

// Basic JSON parsing
var result = await Curl.GetAsync(&quot;https://api.example.com/user/123&quot;);
var json = JsonDocument.Parse(result.Body);
var userName = json.RootElement.GetProperty(&quot;name&quot;).GetString();

// Deserialize to strongly-typed objects
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}

var result = await Curl.GetAsync(&quot;https://api.example.com/user/123&quot;);
var user = JsonSerializer.Deserialize&lt;User&gt;(result.Body);
</code></pre>
<h3 id="sending-json-data">Sending JSON Data</h3>
<pre><code class="lang-csharp">// Using anonymous objects
var data = new
{
    name = &quot;John Doe&quot;,
    email = &quot;john@example.com&quot;,
    age = 30
};

var json = JsonSerializer.Serialize(data);
var result = await Curl.PostAsync(&quot;https://api.example.com/users&quot;, json, &quot;application/json&quot;);

// Using strongly-typed objects
var user = new User { Name = &quot;Jane Doe&quot;, Email = &quot;jane@example.com&quot; };
var json = JsonSerializer.Serialize(user);
var result = await Curl.PostAsync(&quot;https://api.example.com/users&quot;, json, &quot;application/json&quot;);
</code></pre>
<h3 id="working-with-json-arrays">Working with JSON Arrays</h3>
<pre><code class="lang-csharp">// Parse JSON array
var result = await Curl.GetAsync(&quot;https://api.example.com/users&quot;);
var users = JsonSerializer.Deserialize&lt;List&lt;User&gt;&gt;(result.Body);

foreach (var user in users)
{
    Console.WriteLine($&quot;{user.Name} - {user.Email}&quot;);
}

// Send JSON array
var users = new[]
{
    new User { Name = &quot;User1&quot;, Email = &quot;user1@example.com&quot; },
    new User { Name = &quot;User2&quot;, Email = &quot;user2@example.com&quot; }
};

var json = JsonSerializer.Serialize(users);
var result = await Curl.PostAsync(&quot;https://api.example.com/users/bulk&quot;, json, &quot;application/json&quot;);
</code></pre>
<h2 id="authentication">Authentication</h2>
<h3 id="basic-authentication">Basic Authentication</h3>
<pre><code class="lang-csharp">// Using curl command syntax
var result = await Curl.ExecuteAsync(&quot;curl -u username:password https://api.example.com/secure&quot;);

// Using builder
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/secure&quot;)
    .SetAuthentication(&quot;username&quot;, &quot;password&quot;)
    .Build()
    .ExecuteAsync();

// Using Authorization header
var credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes(&quot;username:password&quot;));
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/secure&quot;)
    .AddHeader(&quot;Authorization&quot;, $&quot;Basic {credentials}&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="bearer-token-authentication">Bearer Token Authentication</h3>
<pre><code class="lang-csharp">// Using Authorization header
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/secure&quot;)
    .AddHeader(&quot;Authorization&quot;, &quot;Bearer your-token-here&quot;)
    .Build()
    .ExecuteAsync();

// Reusable authenticated client
public class AuthenticatedApiClient
{
    private readonly string _token;

    public AuthenticatedApiClient(string token)
    {
        _token = token;
    }

    public async Task&lt;CurlResult&gt; GetAsync(string endpoint)
    {
        return await new CurlRequestBuilder()
            .SetUrl($&quot;https://api.example.com{endpoint}&quot;)
            .AddHeader(&quot;Authorization&quot;, $&quot;Bearer {_token}&quot;)
            .Build()
            .ExecuteAsync();
    }
}
</code></pre>
<h3 id="api-key-authentication">API Key Authentication</h3>
<pre><code class="lang-csharp">// API key in header
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/data&quot;)
    .AddHeader(&quot;X-API-Key&quot;, &quot;your-api-key&quot;)
    .Build()
    .ExecuteAsync();

// API key in query parameter
var result = await Curl.GetAsync(&quot;https://api.example.com/data?api_key=your-api-key&quot;);
</code></pre>
<h3 id="oauth-20-flow">OAuth 2.0 Flow</h3>
<pre><code class="lang-csharp">// Step 1: Get access token
var tokenRequest = new
{
    grant_type = &quot;client_credentials&quot;,
    client_id = &quot;your-client-id&quot;,
    client_secret = &quot;your-client-secret&quot;
};

var tokenResult = await Curl.PostAsync(
    &quot;https://auth.example.com/token&quot;,
    JsonSerializer.Serialize(tokenRequest),
    &quot;application/json&quot;
);

var tokenResponse = JsonDocument.Parse(tokenResult.Body);
var accessToken = tokenResponse.RootElement.GetProperty(&quot;access_token&quot;).GetString();

// Step 2: Use access token
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/protected&quot;)
    .AddHeader(&quot;Authorization&quot;, $&quot;Bearer {accessToken}&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h2 id="file-operations">File Operations</h2>
<h3 id="downloading-files">Downloading Files</h3>
<pre><code class="lang-csharp">// Download to memory
var result = await Curl.GetAsync(&quot;https://example.com/file.pdf&quot;);
File.WriteAllBytes(&quot;downloaded.pdf&quot;, Encoding.UTF8.GetBytes(result.Body));

// Download with progress tracking
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://example.com/largefile.zip&quot;)
    .SetProgressCallback((downloaded, total) =&gt;
    {
        var percent = (downloaded / (double)total) * 100;
        Console.WriteLine($&quot;Downloaded: {percent:F2}%&quot;);
    })
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="uploading-files">Uploading Files</h3>
<pre><code class="lang-csharp">// Upload file as binary
var fileBytes = File.ReadAllBytes(&quot;document.pdf&quot;);
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/upload&quot;)
    .SetMethod(&quot;POST&quot;)
    .SetBody(fileBytes)
    .AddHeader(&quot;Content-Type&quot;, &quot;application/pdf&quot;)
    .Build()
    .ExecuteAsync();

// Multipart form upload
var boundary = $&quot;----Boundary{Guid.NewGuid():N}&quot;;
var content = new MultipartFormDataContent(boundary);
content.Add(new StringContent(&quot;John Doe&quot;), &quot;name&quot;);
content.Add(new ByteArrayContent(fileBytes), &quot;file&quot;, &quot;document.pdf&quot;);

var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/upload&quot;)
    .SetMethod(&quot;POST&quot;)
    .SetBody(await content.ReadAsStringAsync())
    .AddHeader(&quot;Content-Type&quot;, $&quot;multipart/form-data; boundary={boundary}&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="working-with-streams">Working with Streams</h3>
<pre><code class="lang-csharp">// Stream response handling
var result = await Curl.GetAsync(&quot;https://api.example.com/stream&quot;);
using var stream = new MemoryStream(Encoding.UTF8.GetBytes(result.Body));
using var reader = new StreamReader(stream);

string line;
while ((line = await reader.ReadLineAsync()) != null)
{
    Console.WriteLine($&quot;Received: {line}&quot;);
}
</code></pre>
<h2 id="advanced-patterns">Advanced Patterns</h2>
<h3 id="retry-logic">Retry Logic</h3>
<pre><code class="lang-csharp">public async Task&lt;CurlResult&gt; ExecuteWithRetry(string url, int maxRetries = 3)
{
    for (int i = 0; i &lt;= maxRetries; i++)
    {
        try
        {
            var result = await Curl.GetAsync(url);
            if (result.IsSuccess)
                return result;

            if (i &lt; maxRetries &amp;&amp; IsRetryableStatusCode(result.StatusCode))
            {
                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, i))); // Exponential backoff
                continue;
            }

            return result;
        }
        catch (CurlTimeoutException) when (i &lt; maxRetries)
        {
            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, i)));
        }
    }

    throw new Exception($&quot;Failed after {maxRetries} retries&quot;);
}

private bool IsRetryableStatusCode(int statusCode)
{
    return statusCode == 429 || statusCode &gt;= 500;
}
</code></pre>
<h3 id="rate-limiting">Rate Limiting</h3>
<pre><code class="lang-csharp">public class RateLimitedClient
{
    private readonly SemaphoreSlim _semaphore;
    private readonly TimeSpan _resetInterval;
    private DateTime _nextReset;

    public RateLimitedClient(int requestsPerInterval, TimeSpan interval)
    {
        _semaphore = new SemaphoreSlim(requestsPerInterval);
        _resetInterval = interval;
        _nextReset = DateTime.UtcNow.Add(interval);
    }

    public async Task&lt;CurlResult&gt; ExecuteAsync(string url)
    {
        await _semaphore.WaitAsync();

        try
        {
            if (DateTime.UtcNow &gt; _nextReset)
            {
                _nextReset = DateTime.UtcNow.Add(_resetInterval);
                _semaphore.Release(Math.Min(_semaphore.CurrentCount + 1, 10));
            }

            return await Curl.GetAsync(url);
        }
        finally
        {
            _ = Task.Delay(_resetInterval).ContinueWith(_ =&gt; _semaphore.Release());
        }
    }
}
</code></pre>
<h3 id="parallel-requests">Parallel Requests</h3>
<pre><code class="lang-csharp">// Execute multiple requests in parallel
var urls = new[]
{
    &quot;https://api.example.com/data1&quot;,
    &quot;https://api.example.com/data2&quot;,
    &quot;https://api.example.com/data3&quot;
};

var tasks = urls.Select(url =&gt; Curl.GetAsync(url));
var results = await Task.WhenAll(tasks);

foreach (var result in results)
{
    Console.WriteLine($&quot;Status: {result.StatusCode}, Body length: {result.Body.Length}&quot;);
}

// Parallel with cancellation
var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
var tasks = urls.Select(url =&gt; Curl.GetAsync(url, cts.Token));
var results = await Task.WhenAll(tasks);
</code></pre>
<h3 id="connection-pooling">Connection Pooling</h3>
<pre><code class="lang-csharp">// Reuse connections for multiple requests
public class ApiClient : IDisposable
{
    private readonly HttpClient _httpClient;

    public ApiClient()
    {
        _httpClient = new HttpClient
        {
            BaseAddress = new Uri(&quot;https://api.example.com&quot;),
            Timeout = TimeSpan.FromSeconds(30)
        };
    }

    public async Task&lt;string&gt; GetDataAsync(string endpoint)
    {
        // CurlDotNet can work with HttpClient for connection pooling
        var response = await _httpClient.GetAsync(endpoint);
        return await response.Content.ReadAsStringAsync();
    }

    public void Dispose()
    {
        _httpClient?.Dispose();
    }
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<h3 id="basic-error-handling">Basic Error Handling</h3>
<pre><code class="lang-csharp">try
{
    var result = await Curl.GetAsync(&quot;https://api.example.com/data&quot;);
    result.EnsureSuccessStatusCode();
    // Process successful result
}
catch (CurlHttpException httpEx)
{
    Console.WriteLine($&quot;HTTP Error {httpEx.StatusCode}: {httpEx.Message}&quot;);
    if (httpEx.IsRateLimited)
    {
        var retryAfter = httpEx.GetRetryAfter();
        Console.WriteLine($&quot;Rate limited. Retry after: {retryAfter}&quot;);
    }
}
catch (CurlTimeoutException timeoutEx)
{
    Console.WriteLine($&quot;Request timed out: {timeoutEx.Message}&quot;);
}
catch (CurlException curlEx)
{
    Console.WriteLine($&quot;Curl error: {curlEx.Message}&quot;);
    foreach (var suggestion in curlEx.Suggestions)
    {
        Console.WriteLine($&quot;  - {suggestion}&quot;);
    }
}
</code></pre>
<h3 id="custom-error-handling">Custom Error Handling</h3>
<pre><code class="lang-csharp">public class ApiErrorHandler
{
    public async Task&lt;T&gt; ExecuteWithHandling&lt;T&gt;(
        Func&lt;Task&lt;CurlResult&gt;&gt; request,
        Func&lt;CurlResult, T&gt; processResult)
    {
        try
        {
            var result = await request();

            if (!result.IsSuccess)
            {
                throw result.StatusCode switch
                {
                    401 =&gt; new UnauthorizedException(&quot;Authentication required&quot;),
                    403 =&gt; new ForbiddenException(&quot;Access denied&quot;),
                    404 =&gt; new NotFoundException(&quot;Resource not found&quot;),
                    429 =&gt; new RateLimitException(&quot;Too many requests&quot;),
                    &gt;= 500 =&gt; new ServerException(&quot;Server error&quot;),
                    _ =&gt; new ApiException($&quot;Request failed: {result.StatusCode}&quot;)
                };
            }

            return processResult(result);
        }
        catch (CurlException ex)
        {
            throw new ApiException(&quot;Network error&quot;, ex);
        }
    }
}
</code></pre>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="caching-responses">Caching Responses</h3>
<pre><code class="lang-csharp">public class CachedApiClient
{
    private readonly MemoryCache _cache;

    public CachedApiClient()
    {
        _cache = new MemoryCache(new MemoryCacheOptions
        {
            SizeLimit = 100
        });
    }

    public async Task&lt;string&gt; GetCachedAsync(string url)
    {
        if (_cache.TryGetValue(url, out string cached))
        {
            return cached;
        }

        var result = await Curl.GetAsync(url);

        if (result.IsSuccess)
        {
            _cache.Set(url, result.Body, new MemoryCacheEntryOptions
            {
                Size = 1,
                SlidingExpiration = TimeSpan.FromMinutes(5)
            });
        }

        return result.Body;
    }
}
</code></pre>
<h3 id="request-compression">Request Compression</h3>
<pre><code class="lang-csharp">// Enable gzip compression for requests and responses
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/data&quot;)
    .AddHeader(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;)
    .AddHeader(&quot;Content-Encoding&quot;, &quot;gzip&quot;)
    .SetBody(CompressString(jsonData))
    .Build()
    .ExecuteAsync();

private byte[] CompressString(string text)
{
    var bytes = Encoding.UTF8.GetBytes(text);
    using var output = new MemoryStream();
    using (var gzip = new GZipStream(output, CompressionLevel.Optimal))
    {
        gzip.Write(bytes, 0, bytes.Length);
    }
    return output.ToArray();
}
</code></pre>
<h2 id="testing-and-mocking">Testing and Mocking</h2>
<h3 id="unit-testing-with-curldotnet">Unit Testing with CurlDotNet</h3>
<pre><code class="lang-csharp">[TestClass]
public class ApiClientTests
{
    [TestMethod]
    public async Task GetUser_ReturnsValidUser()
    {
        // Arrange
        var expectedUser = new User { Id = 1, Name = &quot;Test User&quot; };

        // Act
        var result = await Curl.GetAsync(&quot;https://jsonplaceholder.typicode.com/users/1&quot;);
        var user = JsonSerializer.Deserialize&lt;User&gt;(result.Body);

        // Assert
        Assert.IsNotNull(user);
        Assert.AreEqual(1, user.Id);
        Assert.IsFalse(string.IsNullOrEmpty(user.Name));
    }
}
</code></pre>
<h3 id="integration-testing">Integration Testing</h3>
<pre><code class="lang-csharp">[TestClass]
[TestCategory(&quot;Integration&quot;)]
public class ApiIntegrationTests
{
    private string _baseUrl = &quot;https://api.example.com&quot;;

    [TestMethod]
    public async Task CreateAndDeleteUser_Workflow()
    {
        // Create user
        var createData = JsonSerializer.Serialize(new { name = &quot;Test User&quot; });
        var createResult = await Curl.PostAsync($&quot;{_baseUrl}/users&quot;, createData, &quot;application/json&quot;);
        Assert.AreEqual(201, createResult.StatusCode);

        var userId = JsonDocument.Parse(createResult.Body)
            .RootElement.GetProperty(&quot;id&quot;).GetInt32();

        // Verify user exists
        var getResult = await Curl.GetAsync($&quot;{_baseUrl}/users/{userId}&quot;);
        Assert.AreEqual(200, getResult.StatusCode);

        // Delete user
        var deleteResult = await Curl.DeleteAsync($&quot;{_baseUrl}/users/{userId}&quot;);
        Assert.AreEqual(204, deleteResult.StatusCode);

        // Verify user deleted
        var verifyResult = await Curl.GetAsync($&quot;{_baseUrl}/users/{userId}&quot;);
        Assert.AreEqual(404, verifyResult.StatusCode);
    }
}
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="common-issues-and-solutions">Common Issues and Solutions</h3>
<h4 id="connection-timeouts">Connection Timeouts</h4>
<pre><code class="lang-csharp">// Increase timeout for slow endpoints
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://slow-api.example.com/data&quot;)
    .SetTimeout(TimeSpan.FromMinutes(5))
    .Build()
    .ExecuteAsync();
</code></pre>
<h4 id="ssl-certificate-issues">SSL Certificate Issues</h4>
<pre><code class="lang-csharp">// Disable SSL verification (development only!)
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://self-signed.example.com&quot;)
    .SetSslVerification(false)
    .Build()
    .ExecuteAsync();
</code></pre>
<h4 id="proxy-configuration">Proxy Configuration</h4>
<pre><code class="lang-csharp">// Use proxy server
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/data&quot;)
    .SetProxy(&quot;http://proxy.company.com:8080&quot;)
    .SetProxyAuthentication(&quot;username&quot;, &quot;password&quot;)
    .Build()
    .ExecuteAsync();
</code></pre>
<h4 id="debugging-requests">Debugging Requests</h4>
<pre><code class="lang-csharp">// Enable verbose output for debugging
var result = await new CurlRequestBuilder()
    .SetUrl(&quot;https://api.example.com/data&quot;)
    .SetVerbose(true)
    .SetDebugCallback((type, data) =&gt;
    {
        Console.WriteLine($&quot;[{type}] {data}&quot;);
    })
    .Build()
    .ExecuteAsync();
</code></pre>
<h3 id="logging">Logging</h3>
<pre><code class="lang-csharp">public class LoggingApiClient
{
    private readonly ILogger&lt;LoggingApiClient&gt; _logger;

    public LoggingApiClient(ILogger&lt;LoggingApiClient&gt; logger)
    {
        _logger = logger;
    }

    public async Task&lt;CurlResult&gt; ExecuteAsync(string url)
    {
        _logger.LogInformation(&quot;Executing request to {Url}&quot;, url);
        var stopwatch = Stopwatch.StartNew();

        try
        {
            var result = await Curl.GetAsync(url);

            _logger.LogInformation(
                &quot;Request completed: {StatusCode} in {ElapsedMs}ms&quot;,
                result.StatusCode,
                stopwatch.ElapsedMilliseconds
            );

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                &quot;Request failed after {ElapsedMs}ms&quot;,
                stopwatch.ElapsedMilliseconds
            );
            throw;
        }
    }
}
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Always dispose resources</strong>: Use <code>using</code> statements or implement <code>IDisposable</code></li>
<li><strong>Handle errors gracefully</strong>: Catch specific exception types</li>
<li><strong>Use timeouts</strong>: Prevent hanging requests</li>
<li><strong>Validate inputs</strong>: Check URLs and parameters before sending</li>
<li><strong>Log requests</strong>: Track API usage and errors</li>
<li><strong>Use connection pooling</strong>: Reuse HTTP connections</li>
<li><strong>Implement retry logic</strong>: Handle transient failures</li>
<li><strong>Respect rate limits</strong>: Implement throttling</li>
<li><strong>Secure credentials</strong>: Never hardcode secrets</li>
<li><strong>Test thoroughly</strong>: Unit and integration tests</li>
</ol>
<h2 id="further-resources">Further Resources</h2>
<ul>
<li><a href="https://jacob-mellor.github.io/curl-dot-net">CurlDotNet API Reference</a></li>
<li><a href="../samples/README.md">Sample Applications</a></li>
<li><a href="LIBCURL_MAPPING.html">libcurl Mapping Guide</a></li>
<li><a href="troubleshooting/README.html">Troubleshooting Guide</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/jacob-mellor/curl-dot-net/blob/master/docs/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright Â© 2024 CurlDotNet | <a href='https://www.nuget.org/packages/CurlDotNet/'>NuGet</a> | <a href='https://github.com/jacob-mellor/curl-dot-net'>GitHub</a>
        </div>
      </div>
    </footer>
  </body>
</html>
